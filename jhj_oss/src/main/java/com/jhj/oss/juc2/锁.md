# jhj_cloud
synchronized 原理？
# 乐观和悲观：
乐观（CAS） 加版本号
悲观（synchronized）
# 8锁例子
作用于实例方法，对象锁
作用于代码块，对象锁
静态方法锁的是class类，类锁，非静态锁的是对象
synchronized（this）锁对象？
# synchronized 原理
反编译可以看到，用的是 monitorenter 和 monitorexit 指令，一般情况下 1个monitorenter和 2个 monitorexit
monitorenter表示加锁，然后之后有一些属性 _owner:线程id， count：加锁次数 _recursions:代码块重入次数 entryKist:阻塞线程队列 waitSet:等待队列
1）加锁判断 count是否==0，==0表示没有被该锁其他线程占用
2）判断，若count ！=0，判断占用线程是否是自己，若是可重入参数+1，否则的话阻塞队列+1
3）monitorexit 解锁，推出的时候也要看count参数，因为可能重入次数不是0
acc_static ,acc_synchronized 区分是否静态同步方法
# 为什么任何一个对象都可以成为一个锁？
每一个对象都有监视器object monitor
# 公平和非公平
公平锁：雨露均沾
非公平锁：谁抢到就谁的，别人不能获得锁了
new Reentranlock(false); 
为什么默认非公平？ 1非公平锁能充分利用cpu时间，减少空闲状态  2 减：少线程切换
# AQS？
# 可重入锁，又称 递归锁
只同一个线程获取外层锁时候，可以自动获取内层的锁（前提同一把锁），避免死锁。reentranLock 和 synchronized 都是 可重入锁
## 可重入锁又分为两种 隐式 和 显式
隐式：synchronized ，默认就是可重入锁
显式：reentranLock，自己要注意，锁几次，就需要释放几次
# 死锁和排查
1.jps -l 查看进程 jstack + 进程编号 命令
2 图形化工具
# LockSupport与中断机制
interrupt() 中断此线程。设置中断状态（true）。发起一个协商，不会立刻停止线程。如果线程处于sleep,wait,join等状态，会立即退出阻塞状态并抛出异常
interrupted() 测试当前线程是否被中断。返回中断状态，并清除当前中断状态（false）
isInterrupted() 测试此线程是否已经被中断
## 如何中断线程？
1.通过volatile 变量实现
2.通过AtomicBoolean
3.通过Thread自带的api实现方法实现
